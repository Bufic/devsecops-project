pipeline {
    agent {
        docker {
            image 'docker:24.0-dind' // Use a DinD image
            args '--privileged -u root' // Run as root. Required for DinD
        }
    }

    environment {
        REGISTRY = 'ghcr.io'
        IMAGE_NAME = "bufic/devsecops-project"
        NODE_VERSION = '20' // Specify the Node.js version
    }

    stages {
        stage('Setup Environment') {
            steps {
              sh '''
                    # Install bash and curl
                    apk add --no-cache bash curl

                    # Install Node.js 20.x (or higher) using Alpine package manager
                    apk add --no-cache nodejs npm

                    # Install the latest npm
                    npm install -g npm@latest
                '''
            }
        }

        stage('Checkout Code') {
            steps {
                checkout scm
            }
        }

        stage('Install Dependencies') {
            steps {
                sh 'npm ci'
            }
        }

        stage('Unit Testing') {
            steps {
                sh 'npm test'
            }
        }

        stage('Static Code Analysis') {
            steps {
                sh 'npm run lint'
            }
        }

        stage('Build Project') {
            steps {
                sh 'npm run build'
                archiveArtifacts artifacts: 'dist/', fingerprint: true
            }
        }

        stage('Docker Build and Push') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'github-credentials', usernameVariable: 'GITHUB_USERNAME', passwordVariable: 'GITHUB_TOKEN')]) {
                        sh '''
                            echo "${GITHUB_TOKEN}" | docker login ${REGISTRY} -u ${GITHUB_USERNAME} --password-stdin
                        '''
                    }

                    def imageTag = env.GIT_COMMIT ? "sha-${env.GIT_COMMIT}" : "build-${env.BUILD_ID}"
                    def fullImageName = "${REGISTRY}/${IMAGE_NAME}:${imageTag}"

                    sh """
                        docker build -t ${fullImageName} .
                        trivy image --ignore-unfixed --severity CRITICAL,HIGH ${fullImageName} || { echo "Critical or High vulnerabilities found!"; exit 1; }
                        docker push ${fullImageName}
                    """
                }
            }
        }

        stage('Update Kubernetes Deployment') {
            when {
                branch 'main'
            }
            steps {
                script {
                    def imageTag = env.GIT_COMMIT ? "sha-${env.GIT_COMMIT}" : "build-${env.BUILD_ID}"
                    def newImage = "${REGISTRY}/${IMAGE_NAME}:${imageTag}"

                    sh """
                        sed -i "s|image: ${REGISTRY}/.*|image: ${newImage}|g" kubernetes/deployment.yaml
                        echo "Updated deployment to use image: ${newImage}"
                        grep -A 1 "image:" kubernetes/deployment.yaml
                    """

                    withCredentials([usernamePassword(credentialsId: 'github-credentials', usernameVariable: 'GITHUB_USERNAME', passwordVariable: 'GITHUB_TOKEN')]) {
                        sh """
                            git config user.name "Jenkins"
                            git config user.email "jenkins@example.com"
                            git add kubernetes/deployment.yaml
                            git commit -m "Update Kubernetes deployment with new image tag: ${imageTag} [skip ci]" || { echo "Failed to commit changes"; exit 1; }
                            git push https://${GITHUB_USERNAME}:${GITHUB_TOKEN}@github.com/Bufic/devsecops-project.git HEAD:main
                        """
                    }
                }
            }
        }

        stage('Deploy to Kind') {
            steps {
                script {
                    def imageTag = env.GIT_COMMIT ? "sha-${env.GIT_COMMIT}" : "build-${env.BUILD_ID}"
                    def fullImageName = "${REGISTRY}/${IMAGE_NAME}:${imageTag}"

                    sh """
                        docker pull ${fullImageName}
                        kind load docker-image ${fullImageName}
                        sed -i "s|image: ${REGISTRY}/.*|image: ${fullImageName}|g" kubernetes/deployment.yaml
                        kubectl apply -f kubernetes/deployment.yaml
                    """
                }
            }
        }
    }

    post {
        always {
            sh 'docker system prune -f' // Clean up unused Docker images
        }
    }
}